title: 深入理解mysql数据库索引及其应用场景
date: 2021-04-24 10:30:00
categories:
 - 数据库
 - mysql索引
sticky: true
top:true
---
> 前言：在数据库中我们最常见的操作就是查询，所以查询的效率高与否很大程度上影响了程序的性能，
而合理的运用索引能够使我们的查询效率更高，提高程序的运行速度

# 索引是什么
   + 根据mysql官方给出的定义：索引用于快速查找具有特定列值的行。
   + 没有索引，mysql必须从第一行开始，然后通读整个表找到相关的行。表越大，那么花费越多。
   + 如果表中有相关列的索引，mysql可以快速确定要在数据文件中查找的位置，而不必查看每一行数据，这比顺序读要快得多。
# 索引有哪些
1.`主键索引`
索引列中的值必须是唯一的，且不允许有空值
2.`唯一索引`
索引列中的值必须是唯一的，允许有空值，允许有多个空值
3.`普通索引`
mysql中基本索引类型，没有什么限制，允许有空值和重复值
4.`全文索引`
全文索引只支持Innodb、MyIsam表格，并且只能对CHAR、VARCHAR、TEXT列。索引总是在整个列上进行；
不支持列前缀索引，如果指定，则忽略前缀长度。
当字段长度较大时，如果创建普通索引，在进行like模糊匹配时效率很低，这时可以创建全文索引
5.`前缀索引`
在文本类型如CHAR、VARCHAR、TEXT类型的列上创建索引时，可以指定索引列的长度。
6.`其他（按照索引列数量分类）`
单列索引
组合索引：组合索引的使用需要遵循最左原则。如果在索引定义中以正确的顺序指定列，则单个组合索引
可以加快对同一表的几种查询的速度。

还有如空间索引等不常用的索引就不一一列举

# 使用explain查询计划来查看索引的命中情况
    使用explain语句，mysql解释了它将如何处理该语句，包括有关如何连接表以及何种顺序连接表的信息
    ，检查所有查询是否真正使用在表中创建的索引
## explain输出格式
|列|意义|详解|
|:---:|:---:|:---:|
|id|该查询标识符|  |
|select_type|该查询类型|  |
|table|表名|  |
|partitions|匹配的分区|查询将从中匹配记录的分区。NULL值用于未分区的表|
|type|联接类型|  |
|possible_keys|可能的索引选择|该possible_keys列指示索引，mysql可以选择从这些索引中查找表中的行|
|key|实际选择的索引|该key列指示mysql实际决定使用的密钥（索引）如果mysql决定使用possible_keys 索引之一来查找行，则将该索引列为键值，但也有不使用possible_keys中索引的情况|
|key_len|所选键的长度|该key_len列指示mysql决定使用的索引的长度，当索引字段为定长数据类型，比如char，int，datetime，如果有是否为NULL的标记，这个标记需要占用1个字节。对于变长数据类型，比如：varchar，除了是否为NULL的标记外，还需要有长度信息，需要占用2个字节|
|ref|列与索引的比较|该ref列显示将哪些列或常量与该key列中命名的索引进行比较，以 从表中选择行|
|rows|估计要检查的行|该rows列表示mysql认为执行查询必须检查的行数|
|filtered|按表条件过滤的行百分比|该filtered列指示按表条件过滤的表行的估计百分比。最大值为100，这表示未对行进行过滤。值从100减小表示过滤量增加。 rows显示检查的估计行数，rows× filtered显示与下表连接的行数|
|Extra|附加信息|此列包含有关mysql如何解析查询的其他信息|

# mysql索引分析（innodb存储引擎）
## 主键索引（聚簇索引）
    每个InnoDB表都有一个聚簇索引，聚簇索引使用B+树组织结构，叶子节点存储的数据是整行记录。一般情况下，
    聚簇索引就是主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个rowId字段来构建聚簇索引。
    InnoDb创建索引的具体规则如下
> 1.但在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。  
  2.如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。  
  3.如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增
  
除聚簇索引之外的所有索引都成为辅助索引，在InnoDB中，辅助索引的叶子节点上存储的是该行的主键值部。
在检索时，InnoDB使用此主键值在聚簇索引中搜索行数据。

### for example
这里以user_innodb为例，user_innodb的id列为`主键`，age列为`普通索引`。
```sql
CREATE TABLE `user_innodb`
(
  `id`       int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) DEFAULT NULL,
  `age`      int(11)     DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `idx_age` (`age`) USING BTREE
) ENGINE = InnoDB;
```
![主键索引例表](/static/img/index/例表.png  "主键索引例表")
InnoDB的数据和索引存储在一个文件t_user_innodb.ibd中。InnoDB的数据组织方式，是聚簇索引。

主键索引的叶子节点会存储数据行，辅助索引只会存储主键值。
![主键索引结构](/static/img/index/主键索引.png  "主键索引结构")
等值查询数据：
```sql
select * from user_innodb where id = 28;
```
+ 先在主键树中从根节点开始检索，将根节点加载到内存，比较28<75，走左路。（1次磁盘IO）
+ 将左子树节点加载到内存中，比较16<28<47，向下检索。（1次磁盘IO）
+ 检索到叶节点，将节点加载到内存中遍历，比较16<28，18<28，28=28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端。（1次磁盘IO）

`磁盘IO数量：3次。`
![主键索引查询步骤](/static/img/index/主键索引查询步骤.png  "主键索引查询步骤")  
## 辅助索引
除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址。

以表user_innodb的age列为例，age索引的索引结果如下图。
![辅助索引结构](/static/img/index/辅助索引.png  "辅助索引结构")  
底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。

使用辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记录。
画图分析等值查询的情况：
```sql
select * from t_user_innodb where age=19;
```
![辅助索引查询步骤](/static/img/index/辅助索引查询步骤.png  "辅助索引查询步骤")  
根据在辅助索引树中获取的主键id，到主键索引树检索数据的过程称为回表查询。

`磁盘IO数：辅助索引3次+获取记录回表3次`  
## 组合索引
还是以自己创建的一个表为例：表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)。
```sql
CREATE TABLE `abc_innodb`
(
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `a`  int(11)     DEFAULT NULL,
  `b`  int(11)     DEFAULT NULL,
  `c`  varchar(10) DEFAULT NULL,
  `d`  varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `idx_abc` (`a`, `b`, `c`)
) ENGINE = InnoDB;
```
[select * from abc_innodb order by a, b, c, id;]
![组合索引例表](/static/img/index/组合索引例表.png  "组合索引例表")  
组合索引的数据结构：
![组合索引结构](/static/img/index/组合索引结构.png  "组合索引结构")  
### 组合索引的查询过程：
```sql
select * from abc_innodb where a = 13 and b = 16 and c = 4;
```
![组合索引查询步骤](/static/img/index/组合索引查询步骤.png  "组合索引查询步骤")  
### 最左匹配原则
最左前缀匹配原则和联合索引的`索引存储结构`和`检索方式`是有关系的。

在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。

就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。

可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。

`组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(>、<、between、like)就停止匹配。`

## 覆盖索引
覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。
可以看一下执行计划：
覆盖索引的情况：
![使用到覆盖索引](/static/img/index/覆盖索引.png  "使用到覆盖索引")  
未使用到覆盖索引：
![未使用到覆盖索引](/static/img/index/非覆盖索引.png  "未使用到覆盖索引")  

## 使用心得
### 避免回表
在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？

使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）

如果在一个场景下，select id,name,sex from user where name ='zhangsan';这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。

`这里就是一个典型的使用覆盖索引的优化策略减少回表的情况。`
### 联合索引的使用
`联合索引`，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。

`联合索引的创建原则`，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。

联合索引的使用  
+ 考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。  
+ 当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。


